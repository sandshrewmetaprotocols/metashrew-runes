// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "metashrew-runes.proto" (package "metashrew_runes", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message metashrew_runes.RuneId
 */
export interface RuneId {
  /**
   * @generated from protobuf field: uint32 height = 1;
   */
  height: number;
  /**
   * @generated from protobuf field: uint32 txindex = 2;
   */
  txindex: number;
}
/**
 * @generated from protobuf message metashrew_runes.Rune
 */
export interface Rune {
  /**
   * @generated from protobuf field: metashrew_runes.RuneId runeId = 1;
   */
  runeId?: RuneId;
  /**
   * @generated from protobuf field: bytes name = 2;
   */
  name: Uint8Array;
  /**
   * @generated from protobuf field: uint32 divisibility = 3;
   */
  divisibility: number;
  /**
   * @generated from protobuf field: uint32 spacers = 4;
   */
  spacers: number;
  /**
   * @generated from protobuf field: uint32 symbol = 5;
   */
  symbol: number;
}
/**
 * @generated from protobuf message metashrew_runes.BalanceSheetItem
 */
export interface BalanceSheetItem {
  /**
   * @generated from protobuf field: metashrew_runes.Rune rune = 1;
   */
  rune?: Rune;
  /**
   * @generated from protobuf field: bytes balance = 2;
   */
  balance: Uint8Array;
}
/**
 * @generated from protobuf message metashrew_runes.BalanceSheet
 */
export interface BalanceSheet {
  /**
   * @generated from protobuf field: repeated metashrew_runes.BalanceSheetItem entries = 1;
   */
  entries: BalanceSheetItem[];
}
/**
 * @generated from protobuf message metashrew_runes.Outpoint
 */
export interface Outpoint {
  /**
   * @generated from protobuf field: bytes txid = 1;
   */
  txid: Uint8Array;
  /**
   * @generated from protobuf field: uint32 vout = 2;
   */
  vout: number;
}
/**
 * @generated from protobuf message metashrew_runes.Output
 */
export interface Output {
  /**
   * @generated from protobuf field: bytes script = 1;
   */
  script: Uint8Array;
  /**
   * @generated from protobuf field: uint64 value = 2;
   */
  value: bigint;
}
/**
 * @generated from protobuf message metashrew_runes.OutpointResponse
 */
export interface OutpointResponse {
  /**
   * @generated from protobuf field: metashrew_runes.BalanceSheet balances = 1;
   */
  balances?: BalanceSheet;
  /**
   * @generated from protobuf field: metashrew_runes.Outpoint outpoint = 2;
   */
  outpoint?: Outpoint;
  /**
   * @generated from protobuf field: metashrew_runes.Output output = 3;
   */
  output?: Output;
  /**
   * @generated from protobuf field: uint32 height = 4;
   */
  height: number;
  /**
   * @generated from protobuf field: uint32 txindex = 5;
   */
  txindex: number;
}
/**
 * @generated from protobuf message metashrew_runes.PaginationInput
 */
export interface PaginationInput {
  /**
   * @generated from protobuf field: uint32 start = 1;
   */
  start: number;
  /**
   * @generated from protobuf field: uint32 end = 2;
   */
  end: number;
}
/**
 * @generated from protobuf message metashrew_runes.WalletRequest
 */
export interface WalletRequest {
  /**
   * @generated from protobuf field: bytes wallet = 1;
   */
  wallet: Uint8Array;
}
/**
 * @generated from protobuf message metashrew_runes.WalletResponse
 */
export interface WalletResponse {
  /**
   * @generated from protobuf field: repeated metashrew_runes.OutpointResponse outpoints = 1;
   */
  outpoints: OutpointResponse[];
  /**
   * @generated from protobuf field: metashrew_runes.BalanceSheet balances = 2;
   */
  balances?: BalanceSheet;
}
/**
 * @generated from protobuf message metashrew_runes.RunesResponse
 */
export interface RunesResponse {
  /**
   * @generated from protobuf field: repeated metashrew_runes.Rune runes = 1;
   */
  runes: Rune[];
}
/**
 * @generated from protobuf message metashrew_runes.ProtoBurn
 */
export interface ProtoBurn {
  /**
   * @generated from protobuf field: bytes protocol_tag = 1;
   */
  protocolTag: Uint8Array;
  /**
   * @generated from protobuf field: uint32 pointer = 2;
   */
  pointer: number;
}
/**
 * @generated from protobuf message metashrew_runes.uint128
 */
export interface uint128 {
  /**
   * @generated from protobuf field: uint64 lo = 1;
   */
  lo: bigint;
  /**
   * @generated from protobuf field: uint64 hi = 2;
   */
  hi: bigint;
}
/**
 * @generated from protobuf message metashrew_runes.Clause
 */
export interface Clause {
  /**
   * @generated from protobuf field: metashrew_runes.RuneId rune = 1;
   */
  rune?: RuneId;
  /**
   * @generated from protobuf field: metashrew_runes.uint128 amount = 2;
   */
  amount?: uint128;
}
/**
 * @generated from protobuf message metashrew_runes.Predicate
 */
export interface Predicate {
  /**
   * @generated from protobuf field: repeated metashrew_runes.Clause clauses = 1;
   */
  clauses: Clause[];
}
/**
 * @generated from protobuf message metashrew_runes.ProtoMessage
 */
export interface ProtoMessage {
  /**
   * @generated from protobuf field: bytes calldata = 1;
   */
  calldata: Uint8Array;
  /**
   * @generated from protobuf field: metashrew_runes.Predicate predicate = 2;
   */
  predicate?: Predicate;
  /**
   * @generated from protobuf field: uint32 pointer = 3;
   */
  pointer: number;
  /**
   * @generated from protobuf field: uint32 refund_pointer = 4;
   */
  refundPointer: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class RuneId$Type extends MessageType<RuneId> {
  constructor() {
    super("metashrew_runes.RuneId", [
      { no: 1, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      { no: 2, name: "txindex", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
    ]);
  }
  create(value?: PartialMessage<RuneId>): RuneId {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.height = 0;
    message.txindex = 0;
    if (value !== undefined)
      reflectionMergePartial<RuneId>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RuneId,
  ): RuneId {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 height */ 1:
          message.height = reader.uint32();
          break;
        case /* uint32 txindex */ 2:
          message.txindex = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RuneId,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint32 height = 1; */
    if (message.height !== 0)
      writer.tag(1, WireType.Varint).uint32(message.height);
    /* uint32 txindex = 2; */
    if (message.txindex !== 0)
      writer.tag(2, WireType.Varint).uint32(message.txindex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.RuneId
 */
export const RuneId = new RuneId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rune$Type extends MessageType<Rune> {
  constructor() {
    super("metashrew_runes.Rune", [
      { no: 1, name: "runeId", kind: "message", T: () => RuneId },
      { no: 2, name: "name", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "divisibility",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      { no: 4, name: "spacers", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      { no: 5, name: "symbol", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
    ]);
  }
  create(value?: PartialMessage<Rune>): Rune {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = new Uint8Array(0);
    message.divisibility = 0;
    message.spacers = 0;
    message.symbol = 0;
    if (value !== undefined) reflectionMergePartial<Rune>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Rune,
  ): Rune {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* metashrew_runes.RuneId runeId */ 1:
          message.runeId = RuneId.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.runeId,
          );
          break;
        case /* bytes name */ 2:
          message.name = reader.bytes();
          break;
        case /* uint32 divisibility */ 3:
          message.divisibility = reader.uint32();
          break;
        case /* uint32 spacers */ 4:
          message.spacers = reader.uint32();
          break;
        case /* uint32 symbol */ 5:
          message.symbol = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Rune,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* metashrew_runes.RuneId runeId = 1; */
    if (message.runeId)
      RuneId.internalBinaryWrite(
        message.runeId,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bytes name = 2; */
    if (message.name.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.name);
    /* uint32 divisibility = 3; */
    if (message.divisibility !== 0)
      writer.tag(3, WireType.Varint).uint32(message.divisibility);
    /* uint32 spacers = 4; */
    if (message.spacers !== 0)
      writer.tag(4, WireType.Varint).uint32(message.spacers);
    /* uint32 symbol = 5; */
    if (message.symbol !== 0)
      writer.tag(5, WireType.Varint).uint32(message.symbol);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.Rune
 */
export const Rune = new Rune$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BalanceSheetItem$Type extends MessageType<BalanceSheetItem> {
  constructor() {
    super("metashrew_runes.BalanceSheetItem", [
      { no: 1, name: "rune", kind: "message", T: () => Rune },
      { no: 2, name: "balance", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<BalanceSheetItem>): BalanceSheetItem {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.balance = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<BalanceSheetItem>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BalanceSheetItem,
  ): BalanceSheetItem {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* metashrew_runes.Rune rune */ 1:
          message.rune = Rune.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.rune,
          );
          break;
        case /* bytes balance */ 2:
          message.balance = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BalanceSheetItem,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* metashrew_runes.Rune rune = 1; */
    if (message.rune)
      Rune.internalBinaryWrite(
        message.rune,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bytes balance = 2; */
    if (message.balance.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.balance);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.BalanceSheetItem
 */
export const BalanceSheetItem = new BalanceSheetItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BalanceSheet$Type extends MessageType<BalanceSheet> {
  constructor() {
    super("metashrew_runes.BalanceSheet", [
      {
        no: 1,
        name: "entries",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => BalanceSheetItem,
      },
    ]);
  }
  create(value?: PartialMessage<BalanceSheet>): BalanceSheet {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.entries = [];
    if (value !== undefined)
      reflectionMergePartial<BalanceSheet>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BalanceSheet,
  ): BalanceSheet {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated metashrew_runes.BalanceSheetItem entries */ 1:
          message.entries.push(
            BalanceSheetItem.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BalanceSheet,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated metashrew_runes.BalanceSheetItem entries = 1; */
    for (let i = 0; i < message.entries.length; i++)
      BalanceSheetItem.internalBinaryWrite(
        message.entries[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.BalanceSheet
 */
export const BalanceSheet = new BalanceSheet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Outpoint$Type extends MessageType<Outpoint> {
  constructor() {
    super("metashrew_runes.Outpoint", [
      { no: 1, name: "txid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "vout", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
    ]);
  }
  create(value?: PartialMessage<Outpoint>): Outpoint {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.txid = new Uint8Array(0);
    message.vout = 0;
    if (value !== undefined)
      reflectionMergePartial<Outpoint>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Outpoint,
  ): Outpoint {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes txid */ 1:
          message.txid = reader.bytes();
          break;
        case /* uint32 vout */ 2:
          message.vout = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Outpoint,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes txid = 1; */
    if (message.txid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.txid);
    /* uint32 vout = 2; */
    if (message.vout !== 0) writer.tag(2, WireType.Varint).uint32(message.vout);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.Outpoint
 */
export const Outpoint = new Outpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Output$Type extends MessageType<Output> {
  constructor() {
    super("metashrew_runes.Output", [
      { no: 1, name: "script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<Output>): Output {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.script = new Uint8Array(0);
    message.value = 0n;
    if (value !== undefined)
      reflectionMergePartial<Output>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Output,
  ): Output {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes script */ 1:
          message.script = reader.bytes();
          break;
        case /* uint64 value */ 2:
          message.value = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Output,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes script = 1; */
    if (message.script.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.script);
    /* uint64 value = 2; */
    if (message.value !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.Output
 */
export const Output = new Output$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutpointResponse$Type extends MessageType<OutpointResponse> {
  constructor() {
    super("metashrew_runes.OutpointResponse", [
      { no: 1, name: "balances", kind: "message", T: () => BalanceSheet },
      { no: 2, name: "outpoint", kind: "message", T: () => Outpoint },
      { no: 3, name: "output", kind: "message", T: () => Output },
      { no: 4, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      { no: 5, name: "txindex", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
    ]);
  }
  create(value?: PartialMessage<OutpointResponse>): OutpointResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.height = 0;
    message.txindex = 0;
    if (value !== undefined)
      reflectionMergePartial<OutpointResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: OutpointResponse,
  ): OutpointResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* metashrew_runes.BalanceSheet balances */ 1:
          message.balances = BalanceSheet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.balances,
          );
          break;
        case /* metashrew_runes.Outpoint outpoint */ 2:
          message.outpoint = Outpoint.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.outpoint,
          );
          break;
        case /* metashrew_runes.Output output */ 3:
          message.output = Output.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.output,
          );
          break;
        case /* uint32 height */ 4:
          message.height = reader.uint32();
          break;
        case /* uint32 txindex */ 5:
          message.txindex = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: OutpointResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* metashrew_runes.BalanceSheet balances = 1; */
    if (message.balances)
      BalanceSheet.internalBinaryWrite(
        message.balances,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* metashrew_runes.Outpoint outpoint = 2; */
    if (message.outpoint)
      Outpoint.internalBinaryWrite(
        message.outpoint,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* metashrew_runes.Output output = 3; */
    if (message.output)
      Output.internalBinaryWrite(
        message.output,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* uint32 height = 4; */
    if (message.height !== 0)
      writer.tag(4, WireType.Varint).uint32(message.height);
    /* uint32 txindex = 5; */
    if (message.txindex !== 0)
      writer.tag(5, WireType.Varint).uint32(message.txindex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.OutpointResponse
 */
export const OutpointResponse = new OutpointResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaginationInput$Type extends MessageType<PaginationInput> {
  constructor() {
    super("metashrew_runes.PaginationInput", [
      { no: 1, name: "start", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      { no: 2, name: "end", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
    ]);
  }
  create(value?: PartialMessage<PaginationInput>): PaginationInput {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.start = 0;
    message.end = 0;
    if (value !== undefined)
      reflectionMergePartial<PaginationInput>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PaginationInput,
  ): PaginationInput {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 start */ 1:
          message.start = reader.uint32();
          break;
        case /* uint32 end */ 2:
          message.end = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PaginationInput,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint32 start = 1; */
    if (message.start !== 0)
      writer.tag(1, WireType.Varint).uint32(message.start);
    /* uint32 end = 2; */
    if (message.end !== 0) writer.tag(2, WireType.Varint).uint32(message.end);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.PaginationInput
 */
export const PaginationInput = new PaginationInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WalletRequest$Type extends MessageType<WalletRequest> {
  constructor() {
    super("metashrew_runes.WalletRequest", [
      { no: 1, name: "wallet", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<WalletRequest>): WalletRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.wallet = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<WalletRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: WalletRequest,
  ): WalletRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes wallet */ 1:
          message.wallet = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: WalletRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes wallet = 1; */
    if (message.wallet.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.wallet);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.WalletRequest
 */
export const WalletRequest = new WalletRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WalletResponse$Type extends MessageType<WalletResponse> {
  constructor() {
    super("metashrew_runes.WalletResponse", [
      {
        no: 1,
        name: "outpoints",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => OutpointResponse,
      },
      { no: 2, name: "balances", kind: "message", T: () => BalanceSheet },
    ]);
  }
  create(value?: PartialMessage<WalletResponse>): WalletResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.outpoints = [];
    if (value !== undefined)
      reflectionMergePartial<WalletResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: WalletResponse,
  ): WalletResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated metashrew_runes.OutpointResponse outpoints */ 1:
          message.outpoints.push(
            OutpointResponse.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* metashrew_runes.BalanceSheet balances */ 2:
          message.balances = BalanceSheet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.balances,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: WalletResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated metashrew_runes.OutpointResponse outpoints = 1; */
    for (let i = 0; i < message.outpoints.length; i++)
      OutpointResponse.internalBinaryWrite(
        message.outpoints[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* metashrew_runes.BalanceSheet balances = 2; */
    if (message.balances)
      BalanceSheet.internalBinaryWrite(
        message.balances,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.WalletResponse
 */
export const WalletResponse = new WalletResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunesResponse$Type extends MessageType<RunesResponse> {
  constructor() {
    super("metashrew_runes.RunesResponse", [
      {
        no: 1,
        name: "runes",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Rune,
      },
    ]);
  }
  create(value?: PartialMessage<RunesResponse>): RunesResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.runes = [];
    if (value !== undefined)
      reflectionMergePartial<RunesResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RunesResponse,
  ): RunesResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated metashrew_runes.Rune runes */ 1:
          message.runes.push(
            Rune.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RunesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated metashrew_runes.Rune runes = 1; */
    for (let i = 0; i < message.runes.length; i++)
      Rune.internalBinaryWrite(
        message.runes[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.RunesResponse
 */
export const RunesResponse = new RunesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProtoBurn$Type extends MessageType<ProtoBurn> {
  constructor() {
    super("metashrew_runes.ProtoBurn", [
      {
        no: 1,
        name: "protocol_tag",
        kind: "scalar",
        T: 12 /*ScalarType.BYTES*/,
      },
      { no: 2, name: "pointer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
    ]);
  }
  create(value?: PartialMessage<ProtoBurn>): ProtoBurn {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.protocolTag = new Uint8Array(0);
    message.pointer = 0;
    if (value !== undefined)
      reflectionMergePartial<ProtoBurn>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ProtoBurn,
  ): ProtoBurn {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes protocol_tag */ 1:
          message.protocolTag = reader.bytes();
          break;
        case /* uint32 pointer */ 2:
          message.pointer = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ProtoBurn,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes protocol_tag = 1; */
    if (message.protocolTag.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.protocolTag);
    /* uint32 pointer = 2; */
    if (message.pointer !== 0)
      writer.tag(2, WireType.Varint).uint32(message.pointer);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.ProtoBurn
 */
export const ProtoBurn = new ProtoBurn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class uint128$Type extends MessageType<uint128> {
  constructor() {
    super("metashrew_runes.uint128", [
      {
        no: 1,
        name: "lo",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "hi",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<uint128>): uint128 {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.lo = 0n;
    message.hi = 0n;
    if (value !== undefined)
      reflectionMergePartial<uint128>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: uint128,
  ): uint128 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 lo */ 1:
          message.lo = reader.uint64().toBigInt();
          break;
        case /* uint64 hi */ 2:
          message.hi = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: uint128,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint64 lo = 1; */
    if (message.lo !== 0n) writer.tag(1, WireType.Varint).uint64(message.lo);
    /* uint64 hi = 2; */
    if (message.hi !== 0n) writer.tag(2, WireType.Varint).uint64(message.hi);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.uint128
 */
export const uint128 = new uint128$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Clause$Type extends MessageType<Clause> {
  constructor() {
    super("metashrew_runes.Clause", [
      { no: 1, name: "rune", kind: "message", T: () => RuneId },
      { no: 2, name: "amount", kind: "message", T: () => uint128 },
    ]);
  }
  create(value?: PartialMessage<Clause>): Clause {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<Clause>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Clause,
  ): Clause {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* metashrew_runes.RuneId rune */ 1:
          message.rune = RuneId.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.rune,
          );
          break;
        case /* metashrew_runes.uint128 amount */ 2:
          message.amount = uint128.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.amount,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Clause,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* metashrew_runes.RuneId rune = 1; */
    if (message.rune)
      RuneId.internalBinaryWrite(
        message.rune,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* metashrew_runes.uint128 amount = 2; */
    if (message.amount)
      uint128
        .internalBinaryWrite(
          message.amount,
          writer.tag(2, WireType.LengthDelimited).fork(),
          options,
        )
        .join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.Clause
 */
export const Clause = new Clause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Predicate$Type extends MessageType<Predicate> {
  constructor() {
    super("metashrew_runes.Predicate", [
      {
        no: 1,
        name: "clauses",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Clause,
      },
    ]);
  }
  create(value?: PartialMessage<Predicate>): Predicate {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.clauses = [];
    if (value !== undefined)
      reflectionMergePartial<Predicate>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Predicate,
  ): Predicate {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated metashrew_runes.Clause clauses */ 1:
          message.clauses.push(
            Clause.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Predicate,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated metashrew_runes.Clause clauses = 1; */
    for (let i = 0; i < message.clauses.length; i++)
      Clause.internalBinaryWrite(
        message.clauses[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.Predicate
 */
export const Predicate = new Predicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProtoMessage$Type extends MessageType<ProtoMessage> {
  constructor() {
    super("metashrew_runes.ProtoMessage", [
      { no: 1, name: "calldata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "predicate", kind: "message", T: () => Predicate },
      { no: 3, name: "pointer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      {
        no: 4,
        name: "refund_pointer",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<ProtoMessage>): ProtoMessage {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.calldata = new Uint8Array(0);
    message.pointer = 0;
    message.refundPointer = 0;
    if (value !== undefined)
      reflectionMergePartial<ProtoMessage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ProtoMessage,
  ): ProtoMessage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes calldata */ 1:
          message.calldata = reader.bytes();
          break;
        case /* metashrew_runes.Predicate predicate */ 2:
          message.predicate = Predicate.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.predicate,
          );
          break;
        case /* uint32 pointer */ 3:
          message.pointer = reader.uint32();
          break;
        case /* uint32 refund_pointer */ 4:
          message.refundPointer = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ProtoMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes calldata = 1; */
    if (message.calldata.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.calldata);
    /* metashrew_runes.Predicate predicate = 2; */
    if (message.predicate)
      Predicate.internalBinaryWrite(
        message.predicate,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* uint32 pointer = 3; */
    if (message.pointer !== 0)
      writer.tag(3, WireType.Varint).uint32(message.pointer);
    /* uint32 refund_pointer = 4; */
    if (message.refundPointer !== 0)
      writer.tag(4, WireType.Varint).uint32(message.refundPointer);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message metashrew_runes.ProtoMessage
 */
export const ProtoMessage = new ProtoMessage$Type();
